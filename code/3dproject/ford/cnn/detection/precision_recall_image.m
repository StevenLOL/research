function [correct_dets total_dets num_instances precision recall] ...
    = precision_recall_image(pyra, model, ground_truth, thresholds)
% generates the data points for a precision-recall curve for a single image
% using the supplied model and ground truth bounding boxes
% im = RGB image as a matrix
% model = model generated by the felzenszwalb traing code
% ground_truth = n x 4 matrix of ground truth boxes in the form of one box per row 
% organized as (x1 y1 x2 y2) in image coordinates
% thresholds = optional: a set of thresholds to use for the curve

[X Y L S model] = score_image(pyra, model, -3);

correct_dets  = zeros(size(thresholds));
total_dets  = zeros(size(thresholds));
num_instances = length(ground_truth);

% run detection with each thresh
for t = 1:length(thresholds)
    
    % subset out scores based on threshold
    thresh = thresholds(t);
    indx = find(S > thresh);
    tmpX = X(indx);
    tmpY = Y(indx);
    tmpL = L(indx);
    tmpS = S(indx);
    
    % run detection
    [dets] = getdetections(model, pyra.padx, pyra.pady, ...
                                    pyra.scales, tmpX, tmpY, tmpL, tmpS);
    
    %figure(1); showboxes(im, dets);
    
    % run non-maximum suppression
    if ~isempty(dets)
        I = nms(dets, 0.5);
        dets = dets(I,1:4);
    end
    %figure(2); showboxes(im, dets);
    %waitforbuttonpress;
    
    % test detections against ground truth boxes
    correct_dets(t) = 0;
    total_dets(t) = size(dets,1);
        
    if ~isempty(dets)
        for b = 1:num_instances
            overlaps = boxoverlap(dets, ground_truth{b});
            if sum(overlaps > 0.5) > 0
                correct_dets(t) = correct_dets(t) + 1;
            end
        end   
    end
    
end

precision = correct_dets./total_dets;
recall = correct_dets/num_instances;

end

